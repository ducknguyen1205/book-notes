## 22.1 Objective: Tidy Up the Data

This chapter discusses the anxiety caused by gaps in automatically generated primary key values (pseudokeys). Some people assume gaps indicate lost or corrupted data, even though rows may have been legitimately deleted or rolled back.

Example of a perceived problem:

```
bug_id status product_name
1 OPEN Open RoundFile
2 FIXED ReConsider
4 OPEN ReConsider
```

The **Pseudokey Neat-Freak antipattern** arises when someone tries to "fix" these gaps without understanding how databases generate and manage pseudokeys.

---

## 22.2 Antipattern: Filling in the Corners

This antipattern attempts to eliminate gaps in primary key sequences. There are two common approaches, both problematic.

### Assigning Numbers Out of Sequence

Instead of letting the database generate the next pseudokey, new rows are assigned the _lowest unused_ key value.

Example result:

```
bug_id status product_name
1 OPEN Open RoundFile
2 FIXED ReConsider
4 OPEN ReConsider
3 NEW Visual TurboBuilder
```

This requires an inefficient and unsafe query:

```sql
SELECT b1.bug_id + 1
FROM Bugs b1
LEFT OUTER JOIN Bugs AS b2 ON (b1.bug_id + 1 = b2.bug_id)
WHERE b2.bug_id IS NULL
ORDER BY b1.bug_id LIMIT 1;
```

**Problems:**

- Concurrency issues when multiple inserts occur
    
- Performance overhead
    
- Risk of duplicate key errors
    

### Renumbering Existing Rows

Another attempt is to update existing rows to close gaps.

Example:

```sql
UPDATE Bugs SET bug_id = 3 WHERE bug_id = 4;
```

Result:

```
bug_id status product_name
1 NEW Open RoundFile
2 FIXED ReConsider
3 DUPLICATE ReConsider
```

**Problems:**

- Requires repeated updates
    
- High risk of concurrency conflicts
    
- Requires cascading updates to all child tables
    
- May require disabling constraints
    
- Breaks references in external systems
    

Even after cleanup, gaps reappear because pseudokey generators continue incrementing beyond previously used values.

### Manufacturing Data Discrepancies

Reusing primary key values can cause serious logical errors, especially when external systems depend on stable identifiers.

Example scenario:

- A deleted user ID is reused
    
- Old messages or logs still reference that ID
    
- A new user inherits historical blame or data
    

**Rule:** Never reassign or recycle pseudokey values just because they appear unused.

---

## 22.3 How to Recognize the Antipattern

Common warning signs:

- “How can I reuse an autogenerated identity value after I roll back an insert?”
    
- “What happened to bug_id 4?”
    
- “How can I query for the first unused ID?”
    
- “What if I run out of numbers?”
    

These indicate misunderstanding of how pseudokeys work.

---

## 22.4 Legitimate Uses of the Antipattern

If a key value carries _business meaning_, then it is **not a pseudokey**, but a **natural key**. Natural keys may legitimately be updated.

Pseudokeys, by definition, should have no meaning and should never need modification.

---

## 22.5 Solution: Get Over It

Primary keys must be **unique** and **non-null**—they do **not** need to be consecutive.

### Numbering Rows

Do not confuse **row numbers** with **primary keys**:

- Primary keys identify rows in a table
    
- Row numbers identify rows in a query result
    

Row numbers are useful for pagination, not identification.

SQL:2003 provides `ROW_NUMBER()` for this purpose:

```sql
SELECT t1.* FROM
(SELECT a.account_name, b.bug_id, b.summary,
ROW_NUMBER() OVER (ORDER BY a.account_name, b.date_reported) AS rn
FROM Accounts a JOIN Bugs b ON (a.account_id = b.reported_by)) AS t1
WHERE t1.rn BETWEEN 51 AND 100;
```

This produces consecutive row numbers **per query**, independent of primary keys.

### Using GUIDs

Another solution is using globally unique identifiers.

Example (SQL Server 2005):

```sql
CREATE TABLE Bugs (
bug_id UNIQUEIDENTIFIER DEFAULT NEWID(),
-- . . .
);
INSERT INTO Bugs (bug_id, summary)
VALUES (DEFAULT, 'crashes when I save');
```

Example result:

```
bug_id summary
0xff19966f868b11d0b42d00c04fc964ff Crashes when I save
```

**Advantages:**

- Safe for distributed systems
    
- No collisions across servers
    
- No complaints about gaps
    

**Disadvantages:**

- Large (16 bytes)
    
- Hard to type
    
- No ordering semantics
    

### Are Integers a Nonrenewable Resource?

Running out of integers is practically impossible.

- 32-bit unsigned integer at 1,000 inserts/sec → **136 years**
    
- 64-bit integer at 1,000,000 inserts/sec → **584,542 years**
    

Running out of IDs is not a realistic concern.

---

### The Most Important Problem: Managing Expectations

The hardest part is often convincing management not to "tidy" pseudokeys.

**Recommended responses:**

- **Explain the technology**: gaps are normal and harmless
    
- **Explain the cost**: cascading updates, system breakage, testing, retraining
    
- **Use natural keys** if users insist on meaningful identifiers
    
- **Hide pseudokeys** in reports if gaps cause confusion
    

**Final Rule:**

> Use pseudokeys as unique row identifiers. They are not row numbers.