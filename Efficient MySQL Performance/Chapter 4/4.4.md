
Here are three key details that clarify what access patterns are:

- **Plurality:** While discussed in the plural, it's important to recognize that an application has **many individual access patterns**, not an undifferentiated blob. In practice, you modify these patterns individually.
- **Relation to Queries:** An access pattern ultimately refers to a query, and changing queries (and the application) modifies access patterns. However, the focus is on the _interface_ (access pattern) rather than the _implementation_ (query). This broader focus allows for considering different data stores for certain access patterns (e.g., a key-value store instead of MySQL for certain patterns that don't resemble relational queries).
- **Components:** An access pattern consists of a name and a list of technical traits. The **name should be succinct and meaningful** for communication with other engineers, while the **list of technical traits depends on and varies by the data store** (e.g., MySQL vs. Redis).

**Identifying Access Patterns** While ideally, every individual access pattern should be identified, this can be tedious, especially in rapidly changing applications. The sources suggest three reasonable and achievable approaches:

- **Brainstorming:** Collaborate with your team to identify the most obvious and common access patterns.
- **Query Profile Analysis:** Use the query profile to pinpoint the top, slowest access patterns.
- **Code Review:** Examine the application code to discover lesser-known or forgotten access patterns.

You need to follow at least the first or second approach once to achieve the goal of indirect query optimization by changing access patterns. Once an access pattern is identified and named, you should determine the value or answer for each of its nine technical traits. This process itself is an opportunity to learn and potentially improve the application.

**Purpose of Access Patterns** Access patterns serve as a bridge between the concept of high-performance MySQL requiring a high-performance application (as discussed in "Toyota and Ferrari" on page 130) and the practical application changes needed to achieve this. They help determine (and sometimes dictate) how to re-engineer an application for better database performance.

**Nine Traits of MySQL Data Access Patterns** Here are the nine traits of data access patterns for MySQL, along with their detailed explanations:

1. **Read/Write:**
    
    - This trait determines if the access **reads or writes data**.
    - **Read access** is straightforward: `SELECT`.
    - **Write access** includes `INSERT`, `UPDATE`, and `DELETE`. Although `INSERT...SELECT` or `UPDATE`/`DELETE` with a `WHERE` clause involve reads, for simplicity, all `INSERT`, `UPDATE`, and `DELETE` operations are considered write access.
    - Reads and writes have different internal technical impacts on MySQL, and scaling them often requires different application changes.
    - Knowing if an application is read-heavy or write-heavy helps focus attention on relevant changes, such as offloading reads to replicas or caches ("Offload Reads" on page 141) or enqueuing writes ("Enqueue Writes" on page 145).
2. **Throughput:**
    
    - This trait measures the **Queries Per Second (QPS) and its variation** for a data access pattern.
    - **High QPS is not always good**; low throughput can still cause havoc if queries are inefficient (e.g., a `SELECT...FOR UPDATE` causing a table scan and locking many rows).
    - **Variation in QPS** (e.g., burst, steady, cyclical patterns like higher QPS during business hours) is equally important, as it influences strategies for schema changes or data backfilling.
3. **Data Age:**
    
    - This trait describes the **age of the data being accessed**, relative to access order, not time.
    - **Frequently accessed data is considered "young"** and MySQL tries to keep it in memory within the "working set".
    - Accessing "old" data (infrequently accessed data) can be problematic, especially if it's done at a high frequency, as it requires loading data from disk, which can be slow and put pressure on storage I/O.
    - Estimating data age requires understanding the application and its access patterns (e.g., financial transactions are mostly new, user profiles might frequently access old data).
    - This trait is a prerequisite for understanding data partitioning and sharding.
4. **Data Model:**
    
    - This trait clarifies the **underlying data model the access pattern exhibits**, even if MySQL (a relational data store) is being used.
    - MySQL can function with other data models (e.g., key-value), but it might not be the best fit, meaning it won't yield the best performance compared to a purpose-built data store (e.g., RocksDB for key-value).
    - The best practice is to **determine the ideal data model for the access first, then choose a data store built for that model**, rather than forcing access into an available data store's model.
5. **Transaction Isolation:**
    
    - This trait asks **what transaction isolation level the access requires**.
    - Every MySQL query executes in a transaction by default (even a single `SELECT` if InnoDB is the storage engine).
    - Answers fall into "None," "Default" (REPEATABLE READ, which is common), or "Specific." Understanding the required isolation level is crucial for potential migration to other data stores.
6. **Read Consistency:**
    
    - This trait distinguishes between **strong consistency** (read returns the most current value, typically from the source MySQL instance) and **eventual consistency** (read might return an old value but will eventually become current, common on MySQL replicas due to replication lag or caches).
    - Offloading reads to replicas or caches ("Offload Reads" on page 141) is only possible if eventually consistent reads are acceptable for the application and its users.
7. **Concurrency:**
    
    - This trait describes **whether the data is accessed concurrently** (multiple queries reading or writing the same data at the same time).
    - **High concurrency** on writes to the same data leads to greater row lock contention. If this causes lock wait timeouts, solutions include decreasing concurrency or sharding.
    - For reads, high concurrency on infrequently changed data is a good fit for caching.
    - Estimating concurrency, rather than precisely measuring it, is often sufficient, based on application understanding.
8. **Row Access:**
    
    - This trait categorizes how rows are accessed: **point access** (a single row), **range access** (ordered rows between two values), or **random access** (several rows in any order).
    - For **write access**, range and random access with nonunique indexes can exacerbate row lock contention due to gap locks and increase the risk of deadlocks.
    - **Point access works best with sharding** as it maps to a single shard, while range and random access require careful planning to avoid accessing too many shards.
9. **Result Set:**
    
    - This trait examines whether the access **groups, sorts, or limits the result set** using SQL clauses like `GROUP BY`, `ORDER BY`, or `LIMIT`.
    - These clauses influence how the access might be changed or run on another data store.
    - Optimizing access that groups or sorts rows is important, and using SQL aggregate functions (like `COUNT(*)`, `SUM()`, `DISTINCT`) instead of processing the entire result set in the application code can significantly limit the result set size and improve efficiency.

Understanding these access patterns is crucial for making informed decisions about application changes to optimize MySQL performance.