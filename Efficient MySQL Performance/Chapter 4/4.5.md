> If you hear that MySQL has a built-in query cache: forget it and never use it. It was deprecated as of MySQL 5.7.20 and removed as of MySQL 8.0

- **Introduction to Application Changes**
    
    - The core idea is that **MySQL's performance is ultimately limited by the application that uses it**. Metrics like QPS (Queries Per Second) and CPU usage primarily reflect how the application interacts with MySQL, not inherent limitations of MySQL itself.
    - This stage of optimization is tackled last because it demands the most effort, whereas optimizing queries and data can solve many performance issues with less overhead.
- **Audit the Code**
    
    - **Auditing the application code is a foundational step that "always works"**. It involves reviewing the actual queries being executed and understanding their business logic context.
    - Key areas to investigate in the code include:
        - **Unneeded Queries**: Queries that are no longer essential to the application's functionality.
        - **Overly Frequent Queries**: Queries executed more often than necessary.
        - **Aggressive Retries**: Queries that retry too quickly or too many times, potentially exacerbating problems.
        - **Complex Queries**: Queries that are overly large or complex and could be simplified to reduce the work for MySQL.
    - If using **Object-Relational Mapping (ORM)** or other database abstractions, **double-check their defaults and configuration**. Some ORMs might generate inefficient queries (e.g., `SELECT *` instead of selecting only needed columns) or execute extraneous queries like `SHOW WARNINGS` after every application query, which can be wasteful.
    - An **indirect way to audit the code is by examining the query profile**. The query profile provides insights into what queries MySQL is busy executing, and it's common to discover "unknown" queries originating from application code, ORM, or even database operators (DBAs, cloud providers).
    - Adding **application metadata as SQL comments** (e.g., `/* file:app.go line:75 */`) within queries can help trace their origin back to the source code, making future audits easier.
    - Finally, **regularly review the MySQL error log**. A "noisy" error log indicates underlying issues (network, authentication, replication, configuration, non-deterministic queries) that need to be addressed.
- **Offload Reads**
    
    - This technique aims to **reduce load on the source MySQL instance by distributing read queries** to other MySQL instances (replicas) or cache servers.
    - **Benefits**:
        - **Reduced Source Load**: Frees up time and system resources on the source for writes and other critical operations.
        - **Improved Read Response Time**: Reads are served by instances not burdened with write traffic, leading to faster responses.
    - **Crucial Consideration: Eventual Consistency**: Data served from replicas or caches is "eventually consistent," meaning it might be slightly out-of-date compared to the source due to replication or caching delays. This must be acceptable for the application and its users. For example, a "likes" count on a post might be acceptable if it's slightly behind the absolute latest value.
    - **Multi-Statement Transactions**: Reads that are part of a multi-statement transaction **must** be executed on the source to ensure strong consistency and atomicity.
    - **Degraded Mode**: It is imperative to **design and test the application to function in a degraded mode** when read replicas or caches are offline. This ensures the application remains partially functional rather than completely failing.
    - **Replicas vs. Cache Servers**:
        - **MySQL Replicas** offer simplicity as they inherently stay in sync with the source and require no changes to existing SQL queries.
        - **Cache Servers** (e.g., Redis, Memcached) can be **"incredibly faster" than MySQL**. However, they introduce complexity, requiring the application to manage data updates, invalidation, and eviction.
    - **Cache Durability**: When using a cache, decide if it's **ephemeral** (data can be lost and rebuilt) or **durable** (data persists across failures). This impacts recovery strategies and application design.
- **Enqueue Writes**
    
    - For **write-heavy workloads, using a queue to stabilize write throughput is a best practice and often a requirement**.
    - **Benefit**: A queue allows the application to process changes at a **stable, predictable rate**, even during sudden floods of requests (a "thundering herd"). Without a queue, MySQL might be overwhelmed as it attempts to execute all queries concurrently.
    - **Advantages of Enqueueing Writes**:
        - **Decoupling**: The application can accept writes even if MySQL is temporarily offline.
        - **Recovery**: Failed or timed-out writes can be re-enqueued for later processing.
        - **Event Streams**: If the queue is an event stream (like Kafka), it enables replaying changes.
- **Partition Data**
    
    - When data cannot be deleted or archived, **partitioning (physically separating) data** is crucial, reinforcing the principle that "less data is more performance".
    - **MySQL's built-in partitioning is generally not recommended** due to its complexity in implementation, maintenance, and limited support from third-party tools.
    - The most useful approach is **separating hot (frequently accessed) and cold (infrequently accessed) data**. This moves cold data out of the primary access path, improving performance for hot data.
    - A common example is historical data, like old financial transactions, which are rarely accessed after a certain period. This cold data can be moved to a separate table within the same database, and then deleted from the active "hot" table, typically using rate-limited `INSERT...SELECT` and `DELETE` statements wrapped in a transaction.
- **Don't Use MySQL**
    
    - The author emphasizes that the most significant application change might be to **switch to a different data store** if MySQL is clearly not the best fit for specific access patterns.
    - Examples include:
        - **Graph data**: Better suited for a purpose-built graph database or a key-value store.
        - **Time series data**: Better handled by a time series database or a columnar store.
    - While MySQL can perform surprisingly well even for non-ideal workloads, recognizing when another technology is superior is an "honest assessment" for engineers.
- **Better, Faster Hardware?**
    
    - This section, though about hardware, is included in application changes because it addresses **when it is appropriate to scale up hardware after all other optimization efforts have been exhausted**.
    - A checklist is provided to help determine this:
        - **Prerequisites (must check all)**:
            - Response time is currently too high.
            - Slow queries have been optimized.
            - Data has been deleted or archived.
            - Access patterns have been reviewed and optimized.
        - **Hardware Metrics (must check at least two)**:
            - CPU utilization is consistently greater than 80%.
            - Threads running are consistently greater than the number of CPU cores.
            - Memory is consistently less than 10% of total data size.
            - Storage IOPS utilization is consistently greater than 80%.
    - **IOPS specific considerations**:
        - For **read-heavy workloads**, high IOPS often indicates insufficient memory, leading to data swapping from disk.
        - For **write-heavy workloads**, high IOPS usually means the storage itself isn't fast enough to handle the write volume, necessitating more storage IOPS.
