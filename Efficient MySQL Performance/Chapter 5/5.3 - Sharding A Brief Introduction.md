
- **Designing a new application for sharding**:
    
    - This is the **rarer and incomparably easier path**.
    - It's highly encouraged to design for sharding from the start if needed, as it is much simpler than migrating later.
    - To determine if sharding is necessary, you should **estimate data size and growth for the next four years**. This concept is known as the **"four-year fit,"** where sharding might not be needed if the estimated data size in four years fits within your hardware capacity today.
    - It's also important to estimate the "four-year fit" for other aspects of the application workload, such as queries and access patterns, though these are more difficult to predict for new applications.
    - Consider whether the **data set is bounded or unbounded**.
        - A **bounded data set** has an intrinsic maximum size or intrinsically slow growth (e.g., number of new smartphones released annually).
        - An **unbounded data set** has no intrinsic limits (e.g., user-posted pictures).
        - Since hardware capacity is bounded, applications should always **define and impose extrinsic limits on unbounded data sets**. An unbounded data set strongly indicates the need for sharding, unless old data is frequently deleted or archived.

- **Migrating an existing application to sharding**:
    
    - This is the **more common and significantly more difficult, time-consuming, and risky path**.
    - By the time it's required, the database is typically large, akin to "hauling a boulder uphill".
    - For experienced development teams, expect the migration to take a year or longer.
    - This process involves **copying data from the original single database to the new shards**, often multiple times, as the initial migration is essentially the first resharding.

==**Shard Key**==: To shard MySQL, the application must **programmatically map data to shards**. The **shard key** is the **most fundamental decision** and refers to the column (or columns) by which the data is sharded. The application, not MySQL, is responsible for this mapping and data access, as MySQL has no built-in sharding concept.

An ideal shard key has three properties:

- **High cardinality**: Ensures that data is **evenly distributed across shards** (e.g., a unique identifier for videos).
- **References application entities**: Enables access patterns that **do not cross shards** (e.g., sharding payments by customer to keep all customer payments on the same shard).
- **Small**: As small as possible because it's heavily used, often included in most queries to avoid "scatter queries".

The shard key, combined with the sharding strategy, should also **avoid or mitigate challenges like transactions and joins**.

**Sharding Strategies**: A sharding strategy maps data to shards using the shard key value. The application implements this strategy to route queries to the correct shard. This is a critical decision that is **exceedingly difficult to change** once implemented. There are three common strategies:

- **Hash Sharding**:
    
    - Maps shard key values to shards using a **hashing algorithm**, the **modulo operator**, and the number of shards (N). For example, a hash value of 75482 mod 3 = 2, maps to shard 2.
    - Changing the number of shards (N) typically affects data mapping, but a **consistent hashing algorithm** outputs a consistent hash value independent of N, making it less likely for hash values to change when shards change.
    - **Pros**: Works for all shard keys by abstracting the value to an integer, making it easier to automatically map all shard key values.
    - **Cons**: It's **virtually impossible to manually relocate data** due to the automatic mapping.
    - **Best for**: **Point access** patterns, as one row maps to only one shard.
    - ==**Infeasible for**: **Range access** and **random access**==, generally, due to the likelihood of requiring cross-shard queries.

- **Range Sharding**:
    
    - Defines **contiguous key value ranges** and maps a shard to each range.
    - Requires **defining key value ranges in advance** and a thorough knowledge of data distribution to ensure even distribution.
    - Allows **changing (redefining) ranges**, which helps in manually relocating data, unlike hash sharding.
    - **Best when**: The shard key value range is bounded, you know the minimum and maximum values, the value distribution is mostly even, and the range and distribution are unlikely to change (e.g., sharding stock data by stock symbols AAAA to ZZZZ).
    - **Works well for**: **Point access** (if row access distributes evenly, avoiding "hot shards") and **range access** (if row ranges are within shard ranges).
    - ==**Infeasible for**: **Random access**.==

- **Lookup (Directory) Sharding**:
    
    - Involves a **custom mapping of shard key values to shards** using a lookup table (e.g., a database table, durable cache, or configuration file).
    - Offers the **most flexibility**, but requires maintaining the lookup table.
    - Keys in the lookup table can be singular values or ranges.
    - Sensible when the number of unique shard key values is manageable (e.g., sharding by U.S. state and county name).
    - Provides the advantage of **custom mapping**, allowing you to group low-population data onto one shard, which is not possible with hash or range sharding.
    - **Works with**: **All three row access patterns** (point, range, random). Lookup sharding allows remapping shard key values to alleviate cross-shard queries caused by random access, which is difficult with other strategies.