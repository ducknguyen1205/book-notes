
- **Application Workload**
    
    - **Hardware Capacity is Finite:** A single server, regardless of how powerful, has a finite and limited hardware capacity. Everything that runs on the hardware, including the MySQL instance and its workload, must fit within these limits.
    - **Workload Components:** The application workload is comprised of **queries, data, and access patterns**. These three elements are inextricably linked with respect to performance.
![[Pasted image 20250711103130.png]]
    - **Data Size Impact:** An increasing **data size** is a common reason why the workload can exceed the capacity of a single server. Simply buying a bigger hard drive won't solve the problem if the data size causes other parts of the workload to exceed capacity.
    - **Misconceptions about Scaling:** There's a misconception that a single database can scale to its maximum data size (e.g., 64 TB for an InnoDB table). However, data is only _one_ part of the workload, and the other two (queries and access patterns) cannot be ignored.
![[Pasted image 20250711103154.png]]
    - **Real-world Limitations:** For acceptable performance with a large amount of data on a single server, queries must be simple with exceptionally good indexes, and access patterns must be trivial (e.g., very low-throughput reads).
    - **Conclusion:** Ultimately, MySQL at scale requires sharding because application workloads can significantly outpace the speed and capacity of single-server hardware.

- **Benchmarks Are Synthetic**
    
    - **Artificiality of Benchmarks:** Benchmarks utilize **synthetic (fake) queries, data, and access patterns**. They are designed to stress and measure specific aspects of MySQL under ideal conditions, not to represent real applications or your specific workload.
    - **Limited Applicability:** What you observe as amazing performance in a benchmark (e.g., a 100% write-only workload with perfectly optimized queries) will **not translate to your application**.
    - **Purpose of Benchmarks:** Benchmarks serve important purposes for MySQL experts and the industry, such as comparing hardware, server optimizations, different data stores, and testing MySQL's limits. However, they do not tell you how _your_ application will perform and scale.
    - **Conclusion:** Regardless of benchmark results, MySQL at scale still requires sharding for real-world applications.

- **Writes**
    
    - **Difficulty to Scale:** Writes are inherently difficult to scale on a single MySQL instance due to several factors.
    - **Single Writable Instance:** For high availability, production MySQL setups typically limit writes to a **single source instance** to avoid write conflicts. While MySQL supports multiple writable instances, it's rarely used due to the complexity of write conflicts.
    - **Transactions and Locking:** Transactions rely on locking to ensure consistency. Writes acquire **row locks**, and sometimes they lock significantly more rows than expected. These locks lead to **lock contention**, which severely limits how well writes can scale, especially in write-heavy workloads that access the same data.
    - **Page Flushing (Durability):** The process by which MySQL persists data changes from writes to disk, known as **page flushing**, is a **bottleneck of write performance**. Although MySQL is highly efficient, this process is inherently slow because it must ensure data durability (physically written to disk).
    - **Write Amplification:** This refers to a phenomenon where **one write operation requires multiple additional writes**. A simple example is updating a row in a table with 10 secondary indexes, which could result in 10 additional writes to update those indexes. Page flushing and replication also incur additional writes.
    - **Replication Impact:** All writes must be replicated to other MySQL instances (replicas) for high availability. Semisynchronous replication, for instance, noticeably attenuates transaction throughput due to network latency, as each commit must be acknowledged by at least one replica.
    - **Conclusion:** Sharding is necessary to overcome these formidable challenges and scale write performance effectively.

- **Schema Changes**
    
    - **Frequent Changes:** Schema changes (specifically, table definitions) are practically required and **the largest tables often change frequently** due to their heavy usage.
    - **Time-Consuming:** Altering a large table can take an **untenable amount of timeâ€”days or even weeks**.
    - **Online Schema Change (OSC) Tools:** While tools like `pt-online-schema-change`, `gh-ost`, and `ALTER TABLE` allow these operations to run "online" (without affecting the application), the sheer duration is still a significant blocker.
    - **Blocking Factor:** This long waiting period becomes an increasingly annoying **blocker for engineers** and can even impede organization-level goals.
    - **Conclusion:** MySQL at scale requires sharding because engineers cannot afford to wait days or weeks to change a schema. The goal is to prevent a table from becoming so large that altering it takes an unreasonable amount of time.

- **Operations**
    
    - **Impact of Database Size:** As a database grows larger, routine operations take progressively longer. These operations include:
        - Backup and restore
        - Rebuilding failed instances
        - Upgrading MySQL
        - MySQL shutdown, startup, and crash recovery
    - **Downtime Implications:** While application developers may not directly manage these operations, they are affected if the database administrators are not adept at achieving zero-downtime operations. Cloud providers, for example, typically only _minimize_ downtime, which could still mean hours of offline database time.
    - **Conclusion:** Sharding is necessary to efficiently manage data at scale, making these critical operations more manageable and faster by distributing them across many smaller databases ("pebbles" rather than "boulders").
