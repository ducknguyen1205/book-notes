![[Pasted image 20250714110521.png]]
### Types of Replication

MySQL supports two primary types of replication:

- **Source to Replica Replication**: This is the traditional and fundamental type, having been used by MySQL for over 20 years. It is noted for being fast, reliable, and still widely used today. Unless otherwise specified, MySQL replication typically refers to this type.
- **Group Replication**: Introduced in MySQL 5.7.17, Group Replication is a newer type. ==It establishes a MySQL cluster of primary and secondary instances that utilize a group consensus protocol to synchronize data changes and manage group membership.== This is considered the future of MySQL replication and high availability, though its detailed coverage is deferred in the sources to a future discussion. Other similar database cluster solutions, such as Percona XtraDB Cluster and MariaDB Galera Cluster, are also mentioned but not covered in detail.

It's important to note that replication terminology in MySQL has evolved, with changes occurring as of MySQL 8.0.22 and 8.0.26.

### Source to Replica Replication Flow

In a source to replica setup, a **source MySQL instance** (or "source") is any MySQL server where clients (the application) write data. ==Typically, a single writable source is preferred to prevent write conflicts==. A **replica MySQL instance** (or "replica") is a server that replicates data changes from a source. Replicas should always be **read-only** to avoid "split-brain" scenarios. Multi-source replication is also an available option.

The flow of data changes from a source to a replica involves six key steps:

1. During a **transaction commit** on the source, data changes are written to **binary logs (binlogs)**. These are on-disk files that record data changes as binary log events.
2. An **I/O thread** on the replica reads (or "dumps") binary log events from the source's binary logs. A dedicated "binlog dump thread" on the source facilitates this process.
3. The I/O thread on the replica then writes these binary log events to **relay logs** on the replica, which serve as a local copy of the source's binary logs.
4. A **SQL thread** (also known as an **applier thread**) reads the binary log events from the relay log.
5. The SQL thread then **applies** these binary log events to the data on the replica.
6. The replica, in turn, writes the data changes (applied by its SQL thread) to **its own binary logs**. This is standard practice for high availability, enabling a replica to be promoted as a new source if needed.

==By default, MySQL replication is **asynchronous**.== This means that on the source, a transaction completes after step 1, and the remaining steps occur asynchronously. 
![[Pasted image 20250714103025.png]]
MySQL also supports **semisynchronous replication**, where a transaction on the source completes after step 3 (i.e., after at least one replica acknowledges that it has written the binary log events to its relay logs), but crucially, it does not wait for steps 4 or 5.
The following four steps are an extreme simplification of how a transac‚Äê
tion commits when binary logging and semisynchronous replication are enabled:
1. Prepare transaction commit
2. Flush data changes to binary log
3. Wait for acknowledgment from at least one replica
4. Commit transaction
![[Pasted image 20250714105810.png]]


In the event of a failover (when the source fails), a replica is promoted to become the new source. The old source, once restored, is configured to replicate from the new source, potentially experiencing replication lag as it catches up.

### Binary Log Events

The sources primarily assume **row-based replication (RBR)**, which has been the default `binlog_format` since MySQL 5.7.7. In this context, replication focuses on **transactions** and **binary log events**, rather than individual writes. Data changes are committed to binary logs during the transaction commit phase, after the writes themselves have completed.

Transactions are logically represented and delineated as contiguous events within binary logs. This structured representation is what enables multithreaded replicas to apply these transactions in parallel. For example, a simple transaction involving `BEGIN`, an `UPDATE` that changes one row, a `DELETE` that deletes three rows, and `COMMIT` would be represented by four contiguous events in the binary log: an event for `BEGIN`, an event for the `UPDATE` statement (including a row image), an event for the `DELETE` statement (including three row images), and an event for `COMMIT`.

A **row image** is defined as a binary snapshot of a row both before and after modification. A single SQL statement has the potential to generate numerous row images, leading to large transactions that could cause lag as they propagate through the replication system.

### Replication Lag

**Replication lag** occurs when the process of applying changes on a replica (step 5 in the flow) is slower than the rate at which changes are committed on the source (step 1). The intervening steps, primarily network transfer, are rarely the problem if the network is functioning correctly, as MySQL's binary logs, network protocol, and typical networks are designed for speed and efficiency.

The **I/O thread** on a replica can write binary log events to its relay logs very quickly because it's a relatively simple process of reading from the network and writing sequentially to disk. However, the **SQL thread** faces a more demanding and time-consuming process: applying the actual data changes. This often results in the I/O thread outpacing the SQL thread, leading to the accumulation of events in the relay logs and, consequently, replication lag.

While a single SQL thread is a limiting factor for replication, the underlying cause of lag is typically **high transaction throughput** on the source. MySQL replication itself is inherently fast, with a single SQL thread capable of handling thousands of transactions per second. Replicas can be very fast because they generally do not execute the full workload of the source (e.g., they might not serve reads). Furthermore, with row-based replication (RBR), replicas apply direct binary log events (data changes) rather than re-executing SQL statements, which can be significantly faster as they bypass the need to find matching rows.

Even with semisynchronous replication enabled, lag can still occur. If semisynchronous replication appears to reduce lag, it's often a side effect of network latency throttling the transaction throughput on the source itself.

Despite its inherent speed, replication can be overwhelmed by three main causes: transaction throughput (especially large transactions), post-failure rebuilds, and network issues.