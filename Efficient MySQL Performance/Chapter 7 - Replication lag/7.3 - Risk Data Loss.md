"Risk: Data Loss" is a critical topic in Chapter 7 of "Efficient MySQL Performance," emphasizing that **replication lag is synonymous with data loss**.

### Understanding Data Loss in MySQL Replication

MySQL's default replication method, **asynchronous replication**, inherently carries the risk of data loss. While there are other types like semisynchronous replication and Group Replication, the default asynchronous setup means that the primary purpose of replication—preventing data loss—is not fully guaranteed.

**1. Asynchronous Replication and Data Loss** In asynchronous replication, the source MySQL instance commits a transaction and sends data changes to its binary logs (binlogs). The transaction on the source completes **after these changes are written to its binlogs**, regardless of whether a replica has received them.

- **How Data Loss Occurs:** Consider a scenario where a source instance crashes.
    - Imagine the source commits five transactions to its binary logs.
    - If the replica's I/O thread has only fetched the first three transactions when the source crashes, the **last two transactions are at risk of being lost**.
    - **If MySQL is the cause of the crash** (e.g., a bug), it will usually restart automatically, perform crash recovery, and resume normal operations. In this case, committed transactions are **not lost** as long as MySQL is properly configured for durability, though recovery can take minutes or hours.
    - **If the hardware or operating system causes the crash**, or if the MySQL instance cannot be recovered quickly, a Database Administrator (DBA) will perform a **failover**, promoting a replica to become the new source. In this situation, the transactions that were committed on the old source but not yet replicated to the new source (transactions 4 and 5 in the example) **will be lost**. This is standard practice to avoid prolonged outages, even if it means data loss.
- **"Successover":** When DBAs failover for planned maintenance, no data is lost; this is sometimes called "successover".
- **Inevitable Failure:** Data loss with asynchronous replication is inevitable because hardware and software will eventually fail.
- **Mitigation for Asynchronous Replication:** The only way to mitigate this risk is through **strict adherence to minimizing replication lag**. Treating 10 seconds of lag as "we’re at risk of losing the last 10 seconds of customer data" is crucial.
- **Best Practices for Asynchronous Replication (if used):** If you are running asynchronous replication, MySQL DBAs and experts generally expect you to:
    - **Monitor replication lag with a heartbeat tool** (like pt-heartbeat).
    - **Be alerted anytime** (24/7) when replication lag is too high.
    - **Treat replication lag as data loss** and fix it immediately.
- **Cautionary Tale:** A real-world example illustrates how failures, even due to human error (like accidentally hitting an emergency power off button in a data center), can lead to data loss if not prepared.

**2. Semisynchronous Replication and Mitigation of Data Loss** **Semisynchronous replication (semisync)** is an option designed to prevent data loss.

- **How it Works:** When semisync replication is enabled, the source MySQL instance **waits for at least one replica to acknowledge each transaction** before the transaction commits on the source.
    - **Acknowledgement** means that the replica has successfully **written the binary log events for the transaction to its relay logs** (on disk). It does **not** mean the replica has applied the changes to its data. This "acknowledged when received, not when applied" is why it's called semisynchronous, not fully synchronous.
    - The simplified steps for a transaction commit with semisync replication enabled are:
        1. Prepare transaction commit.
        2. Flush data changes to binary log.
        3. **Wait for acknowledgment from at least one replica.**
        4. Commit transaction.
- **Data Loss Scenario with Semisync:** If the source crashes _before_ it receives acknowledgment for a transaction (e.g., after step 2 but before step 3 or 4 in the simplified steps), that **uncommitted transaction might be lost**. However, this is significantly less worrisome than committed transactions being lost, as the client would have received an error anyway. The key guarantee is that **all committed transactions have replicated to at least one replica**.
- **Impact on Availability and Performance:** Semisynchronous replication **reduces availability** because transactions on the source might stall, timeout, or fail if replicas don't acknowledge in time. Asynchronous replication, by contrast, offers near-instantaneous commit on the source.
- **Reverting to Asynchronous:** By default, semisynchronous replication will **revert to asynchronous** if there aren't enough replicas or if the source times out waiting for an acknowledgment. Allowing this fallback is a best practice to prevent a complete outage.
- **Best Practice:** The book argues that semisynchronous replication is a best practice because **data loss is never acceptable**. It's recommended to learn more about it, test it, and use it if possible.

**3. Replication Lag Still Occurs with Semisynchronous Replication** It's important to note that **semisynchronous replication does not solve or preclude replication lag**. Lag still occurs because the replica's SQL (applier) threads still need to _apply_ the changes, which can be slower than the source committing them, even if the binary logs have been received.

In summary, data loss is a significant risk with asynchronous MySQL replication, directly tied to replication lag. Semisynchronous replication greatly reduces this risk by ensuring committed transactions are safely on at least one replica's disk, but it introduces different trade-offs regarding availability and still allows for replication lag during the application phase of transactions.