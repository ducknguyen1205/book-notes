### Nested-Loop Join (NLJ)

The **Nested-Loop Join (NLJ)** is the **default table join algorithm** in MySQL. It operates much like **nested `foreach` loops in programming code**.

To illustrate the NLJ algorithm, consider a query that joins three tables: `t1 JOIN t2 ON t1.A = t2.B JOIN t3 ON t2.B = t3.C`. If `EXPLAIN` reports the join order as `t1`, `t2`, and `t3`, the NLJ algorithm would function like this pseudocode:

```
func find_rows(table, index, conditions) []rows {
    // Return array of rows in table matching conditions,
    // using index for lookup or table scan if NULL
}

foreach find_rows(t1, some_index, "WHERE ...") {
    foreach find_rows(t2, index_on_B, "WHERE B = <t1.A>") {
        return find_rows(t3, NULL, "WHERE C = <t2.B>")
    }
}
```

**How it works:**

- MySQL begins by using an index (e.g., `some_index`) to find matching rows in the **outermost table (`t1`)**.
- **For each matching row found in `t1`**, MySQL then joins `t2`. It uses an index on the join column (e.g., `index_on_B`) in `t2` to look up rows that match the values from `t1.A`.
- **For each matching row found in `t2`**, MySQL similarly joins `t3`.
- If there's no suitable index on a join column (e.g., `t3.C`), it can result in a **full join** (a table scan on the inner table).
- The process continues, moving to the next matching row from the preceding table once no more rows in the current inner table match.

**Performance implication:**

- ==The **innermost table is accessed very frequently**.==
- ==If a full join occurs on the innermost table, it **makes that access very slow**. For example, if both `t1` and `t2` have 10 matching rows, `t3` would be accessed 100 times (10 * 10).==

### Block Nested-Loop Join (Prior to MySQL 8.0.20)

The **Block Nested-Loop Join algorithm** was designed to **address the problem of frequent inner table access** in the standard NLJ.

**How it works:**

- Join column values from matching rows in the outer tables (e.g., `t1` and `t2`) are **saved in a join buffer**. The size of this buffer is controlled by the `join_buffer_size` system variable.
- When the join buffer is full, MySQL then **scans the innermost table (e.g., `t3`)** and joins each `t3` row that matches the join column values stored in the join buffer.
- Although the join buffer itself is accessed many times, this approach is **faster than performing a table scan for every single matching row** from the preceding tables, as the buffer is in memory.

**Replacement:**

- As of MySQL 8.0.20, the Block Nested-Loop Join algorithm has been **replaced by the Hash Join algorithm**. `EXPLAIN` output for queries that would have used this algorithm in earlier versions might show "Using join buffer (Block Nested Loop)" in the `Extra` field.

### Hash Join (MySQL 8.0.18+)

The **Hash Join algorithm** is a significant performance improvement that **replaces the Block Nested-Loop Join algorithm as of MySQL 8.0.20** (introduced in 8.0.18).

**How it works:**

- Hash Join creates an **in-memory hash table** of the inner (join) tables.
- MySQL then uses this hash table to **look up rows in the join table**, which is **extremely fast**.
- This is because a hash table lookup is a **constant time operation**, meaning its performance is not significantly affected by the number of elements in the table once the hash table is built.

**EXPLAIN Output:**

- `EXPLAIN` indicates a hash join by printing **"Using join buffer (hash join)" in the `Extra` field**. This can be observed in cases where MySQL performs a full table scan on a joined table (e.g., `type: ALL` for a joined table) but uses this optimization to improve performance.

### Key Considerations for Joins

- **MySQL Determines Join Order:** It is crucial to remember that **MySQL determines the table join order itself**, not the order in which tables are written in your `JOIN` clause. ==You **must use `EXPLAIN` to see the actual table join order**. Small changes to a query can significantly alter MySQL's chosen join order.==
- **Avoiding Full Joins is Best Practice:** Regardless of the join algorithm, **avoiding full joins remains the best practice**. A full join (table scan on a joined table) is considered the **"single worst thing a query can do"**. This is because the table scan on the joined table happens _for every matching row from the preceding table_, not just once. The `Select full join` query metric tracks these occurrences.
- **Indexes are Pivotal:** Effective joins rely on effective indexes. The **leftmost prefix requirement** still applies to indexes used in join conditions. While MySQL's optimizer is usually correct in choosing the best execution plan, understanding how indexes are used in joins is vital for performance optimization.
- **EXPLAIN is Indispensable:** To understand how MySQL plans to execute a join (including table join order, table access method, and index usage), the `EXPLAIN` command is necessary. For complex rewrites, `SHOW WARNINGS` immediately after `EXPLAIN` can reveal how MySQL internally interprets and rewrites the SQL statement.

