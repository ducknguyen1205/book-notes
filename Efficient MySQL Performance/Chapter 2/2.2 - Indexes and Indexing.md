# MySQL Indexes: A Visual Introduction

This section provides a detailed introduction to what MySQL indexes are, how they work, and their pivotal role in performance. The discussions primarily apply to standard indexes on InnoDB tables.

**InnoDB Tables Are Indexes**
    ![[Pasted image 20250702171412.png]]
    - A key revelation is that **InnoDB tables are fundamentally B-tree indexes organized by their primary key**.
    - Rows are stored as index records within the leaf nodes of this primary key B-tree structure.
    - **Primary key lookups are extremely fast and efficient** due to the inherent nature of B-tree indexes.
    - **Secondary indexes** are also B-tree indexes, but their leaf nodes store primary key values. When MySQL uses a secondary index to find a row, it performs a **second lookup on the primary key** to retrieve the full row. This highlights the **pivotal importance of the primary key** to overall performance.
    ![[Pasted image 20250702171447.png]]
    ![[Pasted image 20250702171527.png]]
	Figure 2-6. Secondary index lookup for value “Au, Be”
	- ==A table has only one primary key. All other indexes are secondary indexes.==

**Table Access Methods**

MySQL uses three primary methods to access data in tables (which are indexes):

- **Index Lookup**: This is the **fastest and most efficient method**, designed for fast access to large amounts of data by finding specific rows or ranges. Performance generally _requires_ that queries use an index lookup for every table. Examples of access types for index lookups include `const`, `ref`, and `range`.
- **Index Scan**: When an index lookup isn't possible, MySQL might perform a brute-force scan of a secondary index, reading all rows in index order. This can be a "full index scan" or an "index-only scan" (if using a covering index). Index scans are generally discouraged unless the alternative is a full table scan. Sequential access (reads/writes) is faster than random access.
- **Table Scan**: This is the least efficient brute-force method, where MySQL reads all rows in primary key order. **Table scans are generally bad for performance** and should be avoided, though they can be acceptable for very tiny or very low selectivity tables. A `type: ALL` in an `EXPLAIN` plan indicates a full table scan.


## **Leftmost Prefix Requirement**

- To effectively use an index, a query **must utilize a leftmost prefix of the index**. This means using one or more index columns starting from the first column defined in the index.
- The index's underlying B-tree structure is ordered by the index column order, allowing traversal only in that sequence.
- A consequence is that `(a, b)` and `(b, a)` are different indexes.
- ==The primary key is implicitly "appended" to every secondary index (`(S, P)` where `S` are secondary index columns and `P` are primary key columns)==. This means secondary index leaf nodes contain primary key values, increasing the size of secondary indexes. Keeping primary keys small and the number of secondary indexes reasonable is important for memory efficiency.

## **EXPLAIN: Query Execution Plan**

- The `EXPLAIN` command shows MySQL's **query execution plan**, detailing how MySQL _plans_ to execute a query, including table join order, access method, and index usage.
- Key fields in the `EXPLAIN` output:
	- `table`: The table being accessed, listed in MySQL's determined join order.
	- `type`: The table access method (e.g., `ALL` for table scan, `index` for index scan, or `const`, `ref`, `range` for index lookups).
	- `possible_keys`: Lists indexes MySQL _could_ use based on the leftmost prefix requirement.
	- `key`: The name of the index MySQL _will_ use.
	- `ref`: The source of values used for lookups in the index (e.g., `const` for literal values, or a column from a preceding table in a join).
	- `rows`: The estimated number of rows MySQL will examine.
	- `Extra`: Provides additional information about query optimizations (e.g., `Using where`, `Using index`, `Using filesort`, `Using index condition`).

### **Index usage examples for SQL clauses**:

#### **WHERE** 

> Indexes help find matching rows. Access types like `const` (for unique index/PK equality on all columns), `range` (for range conditions like `BETWEEN` or `>`), and `ref` (for equality lookups on leftmost prefix of non-unique indexes) indicate index utilization. `Using where` means MySQL applies WHERE conditions after reading rows.

![[Pasted image 20250702173213.png]]
```SQL
EXPLAIN SELECT * FROM elem WHERE id = 1\G
*************************** 1. row ***************************
 id: 1
 select_type: SIMPLE
 table: elem
 partitions: NULL
 type: const
possible_keys: PRIMARY
 key: PRIMARY
 key_len: 4
 ref: const
 rows: 1
 filtered: 100.00
 Extra: NULL
```
---

![[Pasted image 20250702173230.png]]
```SQL
EXPLAIN SELECT * FROM elem WHERE id > 3 AND id < 6 AND c = 'Cd'\G
*************************** 1. row ***************************
 id: 1
 select_type: SIMPLE
 table: elem
 partitions: NULL
> type: range
possible_keys: PRIMARY
 key: PRIMARY
 key_len: 4
> ref: NULL
> rows: 2
 filtered: 10.00
> Extra: Using where
```
> ==`Using where` reflects that MySQL reads and then filters rows not matching==
---

![[Pasted image 20250702173246.png]]
```SQL
EXPLAIN SELECT * FROM elem WHERE a = 'Au'\G
*************************** 1. row ***************************
 id: 1
 select_type: SIMPLE
 table: elem
 partitions: NULL
> type: ref
possible_keys: idx_a_b
> key: idx_a_b
 key_len: 3
 ref: const
 rows: 1
 filtered: 100.00
 Extra: NULL
 
EXPLAIN SELECT * FROM elem WHERE a = 'Au' AND b = 'Be'\G
*************************** 1. row ***************************
 id: 1
 select_type: SIMPLE
 table: elem
 partitions: NULL
> type: ref
possible_keys: idx_a_b
> key: idx_a_b
 key_len: 6
 ref: const,const
 rows: 1
 filtered: 100.00
 Extra: NULL
```
---

![[Pasted image 20250702173514.png]]
```sql
EXPLAIN SELECT * FROM elem WHERE a = 'Al' AND c = 'Co'\G
*************************** 1. row ***************************
 id: 1
 select_type: SIMPLE
 table: elem
 partitions: NULL
 type: ref
possible_keys: idx_a_b
 key: idx_a_b
 key_len: 3
 ref: const
> rows: 3
 filtered: 10.00
> Extra: Using where
```
---

![[Pasted image 20250702173800.png]]
```sql
EXPLAIN SELECT * FROM elem WHERE b = 'Be'\G
*************************** 1. row ***************************
 id: 1
 select_type: SIMPLE
 table: elem
 partitions: NULL
> type: ALL
possible_keys: NULL
> key: NULL
 key_len: NULL
 ref: NULL
 rows: 10
 filtered: 10.00
 Extra: Using where
```


#### **GROUP BY**

> Indexes can optimize `GROUP BY` because values are implicitly grouped by index order. `Using index` (for covering indexes) and `Using index for group-by` are optimizations. If the leftmost prefix is not strictly met for GROUP BY, MySQL might still use the index but could create a temporary table (`Using temporary`).

```sql
EXPLAIN SELECT a, COUNT(*) FROM elem GROUP BY a\G
*************************** 1. row ***************************
 id: 1
 select_type: SIMPLE
 table: elem
 partitions: NULL
> type: index
possible_keys: idx_a_b
 key: idx_a_b
 key_len: 6
 ref: NULL
 rows: 10
 filtered: 100.00
> Extra: Using index
```
---
![[Pasted image 20250702174024.png]]
```sql
EXPLAIN SELECT a, COUNT(a) FROM elem WHERE a != 'Ar' GROUP BY a\G
*************************** 1. row ***************************
 id: 1
 select_type: SIMPLE
 table: elem
 partitions: NULL
> type: range
possible_keys: idx_a_b
 key: idx_a_b
 key_len: 3
 ref: NULL
 rows: 7
 filtered: 100.00
> Extra: Using where; Using index
```
- “Using where” in the Extra field refers to WHERE a != 'Ar'
---
![[Pasted image 20250702174147.png]]
```sql
EXPLAIN SELECT a, b FROM elem WHERE b = 'B' GROUP BY a\G
*************************** 1. row ***************************
 id: 1
 select_type: SIMPLE
 table: elem
 partitions: NULL
 type: range
possible_keys: idx_a_b
 key: idx_a_b
 key_len: 6
 ref: NULL
 rows: 6
 filtered: 100.00
> Extra: Using where; Using index for group-by
```
- ==If, for example, the equality (=) is changed to not-equal (!=), the query optimization is lost.==
---
![[Pasted image 20250702174803.png]]
```sql
EXPLAIN SELECT b, COUNT(*) FROM elem GROUP BY b\G
*************************** 1. row ***************************
 id: 1
 select_type: SIMPLE
 table: elem
 partitions: NULL
> type: index
possible_keys: idx_a_b
 key: idx_a_b
 key_len: 6
 ref: NULL
 rows: 10
 filtered: 100.00
> Extra: Using index; Using temporary
```

- Notice key: idx_a_b: MySQL uses the index despite the query having no condition on column a. What happened to the leftmost prefix requirement? It’s being met because MySQL is scanning the index (type: index) on column a. You can imagine a condition on column a that’s always true, like a = a.
- Would MySQL still index scan on column a for GROUP BY c? No, it would not; it would do a full table scan. Figure 2-18 works because the index has column b values; it does not have column c values.
- “Using temporary” in the Extra field is a side effect of not having a strict set of leftmost prefix conditions. As MySQL reads column a values from the index, it collects column b values in a temporary table (in memory).


#### **ORDER BY** 

> Indexes can prevent `Using filesort` (sorting rows), which is extra work. An index can optimize `ORDER BY` if the ORDER BY columns form a leftmost prefix, or if a leftmost part of the index is held constant by a WHERE clause, or if the primary key (implicitly appended to secondary indexes) is used for sorting. `EXPLAIN ANALYZE` (MySQL 8.0.18+) can measure the actual time spent on filesort.

There are three ways to use an index to optimize `ORDER BY`. The first and simplest
way is using a leftmost prefix of an index for the `ORDER BY` clause. For table `elem`, that
means:
- `ORDER BY id`
- `ORDER BY a`
- `ORDER BY a, b`

![[Pasted image 20250702175156.png]]
```sql
EXPLAIN SELECT a, b FROM elem WHERE a = 'Ar' ORDER BY b\G
*************************** 1. row ***************************
 id: 1
 select_type: SIMPLE
 table: elem
 partitions: NULL
 type: ref
possible_keys: idx_a_b
 key: idx_a_b
 key_len: 3
 ref: const
 rows: 3
 filtered: 100.00
 Extra: Using index
```
---
Why this command does not cause filesort?
```sql
EXPLAIN SELECT * FROM elem WHERE a = 'Al' AND b = 'B' ORDER BY id\G
*************************** 1. row ***************************
 id: 1
 select_type: SIMPLE
 table: elem
 partitions: NULL
 type: ref
possible_keys: idx_a_b
 key: idx_a_b
 key_len: 16
 ref: const,const
 rows: 2
 filtered: 100.00
> Extra: Using index condition
```
![[Pasted image 20250702175400.png]]
- To prove that the “hidden” primary key allows the ORDER BY to avoid a filesort, let’s remove the condition on column b to invalidate the optimization
![[Pasted image 20250702175954.png]]
```sql
EXPLAIN SELECT * FROM elem WHERE a = 'Al' ORDER BY id\G
*************************** 1. row ***************************
 id: 1
 select_type: SIMPLE
 table: elem
 partitions: NULL
 type: ref
possible_keys: idx_a_b
 key: idx_a_b
 key_len: 8
 ref: const
 rows: 3
 filtered: 100.00
> Extra: Using index condition; Using filesort
```


#### **Covering Indexes**: 
An index that includes all columns referenced in the query, allowing MySQL to read values directly from the index without a primary key lookup. Reported as `Using index` in `Extra`. They are powerful but often impractical for complex queries.

#### **Join Tables**: 

> MySQL uses indexes to join tables, with the main difference being that values for join conditions come from a _preceding table_ in the join order. ==MySQL determines the **best table join order**, not the order written in the query==. The `eq_ref` access type is the best and fastest for joins as it guarantees a single-row lookup. A **full join (`type: ALL` for a joined table) is considered the "single worst thing a query can do"**.

Example:
- Create new table for join
```sql
CREATE TABLE `elem_names` (
 `symbol` char(2) NOT NULL,
 `name` varchar(16) DEFAULT NULL,
 PRIMARY KEY (`symbol`)
) ENGINE=InnoDB;

+--------+-----------+
| symbol | name |
+--------+-----------+
| Ag | Silver |
| Al | Aluminum |
| Ar | Argon |
| At | Astatine |
| Au | Gold |
| B | Boron |
| Be | Beryllium |
| Bi | Bismuth |
| Br | Bromine |
| C | Carbon |
| Cd | Cadmium |
| Ce | Cerium |
| Co | Cobalt |
| Cr | Chromium |
+--------+-----------+
```

![[Pasted image 20250703093531.png]]
```sql
EXPLAIN SELECT name
 FROM elem JOIN elem_names ON (elem.a = elem_names.symbol)
 WHERE a IN ('Ag', 'Au', 'At')\G
*************************** 1. row ***************************
 id: 1
 select_type: SIMPLE
 table: elem
 partitions: NULL
 type: range
possible_keys: idx_a_b
 key: idx_a_b
 key_len: 3
 ref: NULL
 rows: 4
 filtered: 100.00
 Extra: Using where; Using index
*************************** 2. row ***************************
 id: 1
 select_type: SIMPLE
 table: elem_names
 partitions: NULL
> type: eq_ref
possible_keys: PRIMARY
 key: PRIMARY
 key_len: 2
> ref: test.elem.a
 rows: 1
 filtered: 100.00
 Extra: NULL
```

If you `SHOW WARNINGS` immediately after `EXPLAIN`, MySQL prints how it rewrites the query. This is the abridged output of `SHOW WARNINGS`:

```sql
/* select#1 */ select
 `test`.`elem_names`.`name` AS `name`
from
 `test`.`elem`
 join `test`.`elem_names`
where
 ((`test`.`elem_names`.`symbol` = `test`.`elem`.`a`)
 and (`test`.`elem`.`a` in ('Ag','Au','At')))
```

> Never guess or presume the table join order because small changes to a query can yield a significantly different table join order or query execution plan.

To demon‐ strate, the SELECT statement in Figure 2-24 is nearly identically to the SELECT state‐ ment in Figure 2-23 with one tiny difference—can you spot it?

![[Pasted image 20250703094540.png]]

```sql
EXPLAIN SELECT name
 FROM elem JOIN elem_names ON (elem.a = elem_names.symbol)
 WHERE a IN ('Ag', 'Au')\G
*************************** 1. row ***************************
 id: 1
 select_type: SIMPLE
 table: elem_names
 partitions: NULL
 type: range
possible_keys: PRIMARY
 key: PRIMARY
 key_len: 2
 ref: NULL
rows: 2
 filtered: 100.00
 Extra: Using where
*************************** 2. row ***************************
 id: 1
 select_type: SIMPLE
 table: elem
 partitions: NULL
 type: ref
possible_keys: idx_a_b
 key: idx_a_b
 key_len: 3
 ref: test.elem_names.symbol
 rows: 2
 filtered: 100.00
 Extra: Using index
```

```sql
/* select#1 */ select
 `test`.`elem_names`.`name` AS `name`
from
 `test`.`elem` join `test`.`elem_names`
where
 ((`test`.`elem`.`a` = `test`.`elem_names`.`symbol`)
 and (`test`.`elem_names`.`symbol` in ('Ag','Au')))
```

- ==Yes, there it is on the last line: MySQL rewrites the query to use the IN() list as the values for elem_names.symbols instead of elem.a as originally written in the query. ==
- Now you can see (or imagine) that index usage on table elem_names.symbols is a range scan to look up two values: “Ag” and “Au.” 
- Using the primary key, that will be an extremely fast index lookup and match only two rows that MySQL will use to join the second table.
---
- MySQL can join tables without an index. This is called a full join and ==it’s the single worst thing a query can do.==

```sql
EXPLAIN SELECT name
 FROM elem STRAIGHT_JOIN elem_names IGNORE INDEX (PRIMARY)
 ON (elem.a = elem_names.symbol)\G
*************************** 1. row ***************************
 id: 1
 select_type: SIMPLE
 table: elem
 partitions: NULL
 type: index
possible_keys: idx_a_b
 key: idx_a_b
 key_len: 6
 ref: NULL
 rows: 10
 filtered: 100.00
 Extra: Using index
*************************** 2. row ***************************
 id: 1
 select_type: SIMPLE
 table: elem_names
 partitions: NULL
 type: ALL
possible_keys: NULL
 key: NULL
 key_len: NULL
 ref: NULL
 rows: 14
 filtered: 7.14
 Extra: Using where; Using join buffer (hash join)
```

> Normally, MySQL would not choose this query execution plan, which is why I had to force it with STRAIGHT_JOIN and IGNORE INDEX (PRIMARY).

> ==Whenever you see type: ALL for a joined table, stop everything you’re doing and fix it.==

- “Using join buffer (hash join)” in the Extra field refers to the hash join algorithm. Hash join builds an in-memory hash table of values and uses that to lookup rows rather than doing repeated table scans. Hash join is a huge performance improvement.

